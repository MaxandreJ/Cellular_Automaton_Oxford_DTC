#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\renewcommand{\partname}{Partie}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 10page%
\topmargin 10pheight%
\rightmargin 10page%
\bottommargin 10pheight%
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Cellular Automata 
\begin_inset Newline newline
\end_inset

(implemented in C)
\end_layout

\begin_layout Author
Maxandre Jacqueline,
\begin_inset Newline newline
\end_inset

1st-Year SABS student
\end_layout

\begin_layout Part
Motivation
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Three centuries ago science was transformed by the dramatic new idea that
 rules based on mathematical equations could be used to describe the natural
 world.
 My purpose [...] is to initiate another such transformation, and to introduce
 a new kind of science that is based on the much more general types of rules
 that can be embodied in simple computer programs.
\begin_inset Quotes erd
\end_inset

 Stephen Wolfram 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset


\end_layout

\begin_layout Standard
Mathematicians traditionally use mathematical formulas to describe reality,
 but Stephen Wolfram argues that it only makes sense when the behaviour
 of the system under investigation is computationally reducible.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset

 Traditional mathematics tries to find shortcuts, or 
\begin_inset Quotes eld
\end_inset

tricks
\begin_inset Quotes erd
\end_inset

 as Richard Feynman once said, to describe an observed system, so that computing
 predictions involves less computational power than it took for the system
 to perform its behaviour.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset

 One can neverless doubt that such tricks can be found for complex systems.
 Traditional science has focused on reducing complex systems to its elementary
 components so they can be tractable by mathematical tricks, but missing
 at the same time the emergent behaviour of complex interacting systems.
 For example, it is claimed biological systems are extremely complex and
 have emergent properties that cannot be explained, or even predicted, by
 studying their individual parts in isolation.
 
\begin_inset CommandInset citation
LatexCommand cite
key "van2004reductionism"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Models based on cellular automata provide an alternative approach [to differenti
al equations].
 [...] They exhibit [analogous] complicated behavior, but by virtue of simpler
 construction are potentially amenable to a more detailed and complete analysis.
\begin_inset Quotes erd
\end_inset

 Stephen Wolfram 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram1983statistical"

\end_inset


\end_layout

\begin_layout Standard
Some cellular automata (such as rule 30 cellular automaton, see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:The-rule-30"

\end_inset

) exhibit a particularly interesting property called 
\begin_inset Quotes eld
\end_inset

intrinsic randomness generation
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset

.
 A system without random input can behave in what most would call random.
 Stephen Wolfram argues that 
\begin_inset Quotes eld
\end_inset

this is how much of the randomness that we see in nature arises
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/rule_30_cellular_automaton.png
	scale 30

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

rule 30
\begin_inset Quotes erd
\end_inset

 cellular automaton, which seems to be random, although generated by simple
 rules.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:The-rule-30"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The recently-named field of 
\begin_inset Quotes eld
\end_inset

executable biology
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "fisher2007executable"

\end_inset

 that focuses on the design of executable computer algorithms that mimic
 biological phenomena 
\begin_inset CommandInset citation
LatexCommand cite
key "fisher2007executable"

\end_inset

 can be viewed as following the intuition of Stephen Wolfram to develop
 
\begin_inset Quotes eld
\end_inset

a new kind of science
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Cellular automata are [...] idealizations of physical systems in which space
 and time are discrete, and physical quantities take on a finite set of
 discrete values.
\begin_inset Quotes erd
\end_inset

 Stephen Wolfram 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram1983statistical"

\end_inset


\end_layout

\begin_layout Standard
Cellular automata are based on simple rules but can display complex behaviour.
 A cellular automaton consists of a regular lattice, with a discrete variable
 at each site.
 The state of a cellular automaton is completely specified by the values
 of the variables at each site.
 A cellular automaton evolves in discrete time steps and the values of the
 variables at each site are only determined by the values of the variables
 in their neighbourhood at the previous step.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram1983statistical"

\end_inset


\end_layout

\begin_layout Part
Scientific History
\end_layout

\begin_layout Standard
The idea of cellular automata is attributed to Stanislas Ulaw and John Von
 Neumann 
\begin_inset CommandInset citation
LatexCommand cite
key "von1951general"

\end_inset

, in the late 1940s-early 1950s 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset

.
 Interestingly, John Von Neumann discovered this idea while trying to develop
 an abstract model of self-reproduction in biology.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset


\end_layout

\begin_layout Standard
This discovery did not lead to much investigation by science in the following
 years, but one example of a cellular automaton did enter recreational computing
 in the early 1970s with James Conway's Game of Life, that exhibit a range
 of complex behaviours.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wolfram2002new"

\end_inset


\end_layout

\begin_layout Part
My Proposition
\end_layout

\begin_layout Standard
My programme, written in C, can execute a cellular automata of variable
 size, animal grazing rate and food growing rate through command line arguments
 (see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Arguments-can-be"

\end_inset

).
 It can display different amounts of detail depending on whether the –verbose
 flag is activated (see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Comparison-between-the"

\end_inset

).
 The grids resulting from runs of the programme are displayed in the terminal
 (see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Comparison-between-the"

\end_inset

).
\end_layout

\begin_layout Standard
The task of creating a cellular automaton was modelled through an abstract
 data structure representing the different objects that interact in the
 cellular automaton (see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Abstract-class-(data"

\end_inset

) and several functions (see figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:-Abstract-sequence"

\end_inset

).
 A run of the programme is depicted visually on figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:-Abstract-sequence"

\end_inset

.
\end_layout

\begin_layout Standard
My code is available in the appendix.
 I have given variables meaningful names so that the code can be read naturally.
 I have commented more complicated parts of my code, as well as parts for
 which I had to make a choice and I have described what functions perform
 on their first line.
 My code is otherwise available on github at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/MaxandreJ/Cellular_Automaton_Oxford_DTC
\end_layout

\end_inset

.
 My code runs well.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/command_line_argument_5x5.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A 5x5 grid has been created, following the first two arguments given to
 the programme.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename figures/command_line_argument_10x10.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A 10x10 grid has been created, following the first two arguments given to
 the programme.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Arguments can be passed when calling the programme in the command line.
\end_layout

\end_inset

Arguments can be passed when calling the programme in the command line.
 For example, you can make the grid small (sub-figure a), or big (sub-figure
 b).
 Arguments are the following (in this order): number_of_rows, number_of_columns,
 food_growing_rate, animal_grazing_rate, (–verbose).
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Arguments-can-be"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/default_display.png
	scale 35

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Default mode.
 Little information is given but one can see quickly the overall changes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/verbose_display.png
	scale 35

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Verbose mode.
 Detailed information is given but it's hard to see the overall changes.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparison between the default and the verbose mode.
\end_layout

\end_inset

Comparison between the default (sub-figure a) and the verbose (sub-figure
 b) mode.
 
\begin_inset Newline newline
\end_inset

All displays were done on the terminal (also known as 
\begin_inset Quotes eld
\end_inset

ASCII art
\begin_inset Quotes erd
\end_inset

).
 Green cells represent where food is, red cells: animals, yellow cells:
 animals and food.
 If a cell is green, the number displayed in black corresponds to the quantity
 of food available in the cell.
 If a cell is red, the number displayed in black corresponds to the quantity
 of food stored by the animal in that cell.
 If a cell is yellow the number displayed in red corresponds to the quantity
 of food stored by the animal in that cell (in that case, the quantity of
 food stored in the cell is not displayed).
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Comparison-between-the"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/abstract class diagram.png
	lyxscale 40
	scale 30

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Abstract class (data structure) diagram.
\end_layout

\end_inset

Abstract class (data structure) diagram.
 I implemented it using type definitions and structures in a header file.
 I did not try to implement any methods because C is not an object-oriented
 language.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Abstract-class-(data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/sequence diagram.png
	lyxscale 50
	scale 20

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Abstract sequence diagram.
\end_layout

\end_inset

 Abstract sequence diagram.
 I implemented it separating each function in a different file, and using
 a header file to link them together.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:-Abstract-sequence"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part*
Appendix: C Code
\end_layout

\begin_layout Section*
Header
\end_layout

\begin_layout Subsection*
CellularAutomata.h
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#ifndef CELLULAR_AUTOMATA #define CELLULAR_AUTOMATA
\end_layout

\begin_layout Plain Layout

//I need to give the prototype Board first, because functions that I use
 need //that type.
 typedef struct Board Board;
\end_layout

\begin_layout Plain Layout

//Easy access to the position of an element //I use rows and columns instead
 of cartesian coordinates x and y because they are //confusing.
 A matrix doesn't have an orthonormal basis! typedef struct Position { int
 row; int column; } Position;
\end_layout

\begin_layout Plain Layout

//Each food has a distinct quantity and growing_rata.
 In facts, I set it up //so that every Food has the same growing_rate, but
 my data structure allows it //to be different for each individual food.
 typedef struct Food { unsigned int quantity; int growing_rate; } Food;
\end_layout

\begin_layout Plain Layout

Board grow_food(Board my_board);
\end_layout

\begin_layout Plain Layout

//Animals can be present and dead.
 I don't use this distinction but it could be //used if one wanted to have
 zombie animals.
 //Using grazing_area_positions and breeding_area_positions allows easy
 access //to adjacent cells.
 typedef struct Animal { unsigned int present; unsigned int alive; unsigned
 int grazing_rate; unsigned int food_stored; unsigned int number_of_grazing_area
_positions; unsigned int number_of_breeding_area_positions; int step_of_birth;
 Position grazing_area_positions[9]; Position breeding_area_positions[4];
 Position position; } Animal;
\end_layout

\begin_layout Plain Layout

//Animal constructor.
 Board construct_animal(Board my_board, int animal_position_row, int animal_posi
tion_column,   int animal_grazing_rate, int step_number); Board graze(Board
 my_board, Animal my_animal); Board live(Board my_board, Animal my_animal);
 //Each animal will have a "step of birth" based on the step_number that
 they are //born at.
 It allows for newly born animals not to breed instantly.
 Board breed(Board my_board, Animal my_animal, int animal_grazing_rate,
 int step_number);
\end_layout

\begin_layout Plain Layout

typedef struct Cell { Position position; Animal animal; Food food; } Cell;
\end_layout

\begin_layout Plain Layout

//The board, or in cellular automaton parlance "grid" has a cell_array_2D
 that //contains most of the data of this programme.
 The rest could be considered as //"metadata".
 struct Board { unsigned int number_of_rows; unsigned int number_of_columns;
 Cell** cell_array_2D; Position* food_positions; int amount_of_food; int
 number_of_animals; };
\end_layout

\begin_layout Plain Layout

//The board constructor.
 Board construct_board(unsigned int number_of_rows, unsigned int number_of_colum
ns, unsigned int food_growing_rate, unsigned int animal_grazing_rate); Board
 perform_step(Board my_board, int animal_grazing_rate, int step_number,
 int verbose_flag_chosen); void display_board(Board my_board);
\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Main
\end_layout

\begin_layout Subsection*
CellularAutomata.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include <string.h> #include "CellularAutoma
ta.h" /*    Cellular automata by Maxandre Jacqueline */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[]) { 	Board my_board; 	unsigned int number_of_rows
; 	unsigned int number_of_columns; 	unsigned int food_growing_rate; 	unsigned
 int animal_grazing_rate; 	int step_number = 0; 	char* verbose_flag; 	int
 verbose_flag_chosen;
\end_layout

\begin_layout Plain Layout

	///Getting arguments from the command line
\end_layout

\begin_layout Plain Layout

	if(argc == 5) 	{ 		number_of_rows = atoi(argv[1]); 		number_of_columns
 = atoi(argv[2]); 		food_growing_rate = atoi(argv[3]); 		animal_grazing_rate
 = atoi(argv[4]); 	} 	else if(argc == 6) 	{ 		number_of_rows = atoi(argv[1]);
 		number_of_columns = atoi(argv[2]); 		food_growing_rate = atoi(argv[3]);
 		animal_grazing_rate = atoi(argv[4]); 		verbose_flag = malloc(sizeof(char)*str
len(argv[5])); 		verbose_flag = argv[5]; 	} 	else 	{ 	printf("Wrong number
 of arguments.
 They should be given in the following order:
\backslash
n" 	"number_of_rows number_of_columns food_growing_rate animal_grazing_rate
 (--verbose)
\backslash
n"); 	//If the wrong number of argument is given, exit.
 	return(1); 	} 	//Awkward, should've used a library for arg_parse 	if (argc
 == 6) 	verbose_flag_chosen = (strcmp(verbose_flag,"--verbose") == 0); 	else
 	verbose_flag_chosen = 0;
\end_layout

\begin_layout Plain Layout

	my_board = construct_board(number_of_rows, number_of_columns, food_growing_rate
, animal_grazing_rate);
\end_layout

\begin_layout Plain Layout

	printf("
\backslash
nInitial board.
\backslash
n"); 	display_board(my_board);
\end_layout

\begin_layout Plain Layout

	///Iterating until stopped by the user (Ctrl-C) 	while(1) 	{ 		printf("
\backslash
n=== Step number %d ===
\backslash
n", step_number); 		my_board = perform_step(my_board, animal_grazing_rate,
 step_number, verbose_flag_chosen); 		//If verbose_flag_chosen, perform_step
 will do the displaying.
 Otherwise 		//it will be up to main.
 		if (!verbose_flag_chosen) 		{ 			display_board(my_board); 		} 		//To
 pause the programme 		getchar(); 		step_number++; 	}
\end_layout

\begin_layout Plain Layout

	///I remember to free the memory allocated in the heap.
 	///Nevertheless, the code is not exception safe...
 	///C doesn't seem very user-friendly for handling exceptions.
 	///What a surprise.
 	free(my_board.cell_array_2D); 	free(my_board.food_positions); 	free(verbose_flag
); 	return 0; } 
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Functions
\end_layout

\begin_layout Subsection*
breed.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board breed(Board my_board, Animal my_animal, int animal_grazing_rate, int
 step_number) {   //An animal breeds in adjacent cells (at most 1 cell away,
 excluding diagonals)   //on the board.
\end_layout

\begin_layout Plain Layout

  Cell my_bred_cell;   int number_position_breeding_area;   int my_bred_cell_row
;   int my_bred_cell_column;
\end_layout

\begin_layout Plain Layout

  if (my_animal.alive)   {     for (number_position_breeding_area=0;    
   number_position_breeding_area<my_animal.number_of_breeding_area_positions;
       number_position_breeding_area++)     {       my_bred_cell_row = my_animal.
breeding_area_positions[number_position_breeding_area].row;       my_bred_cell_co
lumn = my_animal.breeding_area_positions[number_position_breeding_area].column;
\end_layout

\begin_layout Plain Layout

      my_bred_cell = my_board.cell_array_2D[my_bred_cell_row][my_bred_cell_column
];
\end_layout

\begin_layout Plain Layout

      //An animal can breed on a cell only if an animal is not already present
       if (!my_bred_cell.animal.present)       {         my_board = construct_anim
al(my_board, my_bred_cell_row, my_bred_cell_column,           animal_grazing_rat
e, step_number);       }     }   }
\end_layout

\begin_layout Plain Layout

  return my_board; } 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
construct_animal.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board construct_animal(Board my_board, int animal_position_row, int animal_posit
ion_column,   int animal_grazing_rate, int step_number) {   //Constructor
 for an animal.
 Returns a board with an added animal (so it is   //not exactly a constructor,
 but that'll do).
\end_layout

\begin_layout Plain Layout

  Animal my_animal;   int row_offset;   int column_offset;   int breeding_positi
on_counter = 0;   int grazing_position_counter = 0;   int position_within_border
s;   int up_down_left_xor_right;
\end_layout

\begin_layout Plain Layout

  Cell my_cell_with_animal;
\end_layout

\begin_layout Plain Layout

  my_cell_with_animal = my_board.cell_array_2D[animal_position_row][animal_positi
on_column];
\end_layout

\begin_layout Plain Layout

  my_animal = my_cell_with_animal.animal;   my_animal.position.row = animal_positio
n_row;   my_animal.position.column = animal_position_column;   my_animal.present
 = 1;   my_animal.alive = 1;   my_animal.grazing_rate = animal_grazing_rate;
   //my_animal.food_stored is equivalent to its "health points" (HP).
   my_animal.food_stored = 100;   my_animal.step_of_birth = step_number;
\end_layout

\begin_layout Plain Layout

  //Definition of the positions of the grazing_area for my_animal   //Everywhere
 one unit away from my_animal, including diagonals   for (row_offset = -1
 ;row_offset<=1;row_offset++)     {       for (column_offset = -1 ;column_offset
<=1;column_offset++)         {           //Making sure we're not defining
 positions out of the board         position_within_borders = (        
   (animal_position_row + row_offset >= 0) &&         (animal_position_row
 + row_offset < my_board.number_of_rows) &&         (animal_position_column
 + column_offset >= 0) &&       (animal_position_column + column_offset
 < my_board.number_of_columns));
\end_layout

\begin_layout Plain Layout

        if (position_within_borders)         {           my_animal.grazing_area_p
ositions[grazing_position_counter].row = animal_position_row + row_offset;
           my_animal.grazing_area_positions[grazing_position_counter].column
 = animal_position_column + column_offset;           grazing_position_counter++;
         }         }     }     my_animal.number_of_grazing_area_positions
 = grazing_position_counter;
\end_layout

\begin_layout Plain Layout

  //Definition of the positions of the breeding_area for my_animal   //Everywher
e one unit away from my_animal, excluding diagonals   for (row_offset =
 -1 ;row_offset<=1;row_offset++)   {     for (column_offset = -1 ;column_offset<
=1;column_offset++)       {         //Making sure we're not defining positions
 out of the board         position_within_borders = (           (animal_position
_row + row_offset >= 0) &&           (animal_position_row + row_offset <
 my_board.number_of_rows) &&           (animal_position_column + column_offset
 >= 0) &&         (animal_position_column + column_offset < my_board.number_of_co
lumns)         );         if (position_within_borders)         {       
    up_down_left_xor_right = ((row_offset == 0) || (column_offset == 0))
 &&           (!((row_offset == 0) && (column_offset == 0)));          
 // An animal can only breed up xor down xor left xor right           if
 (up_down_left_xor_right)           {             my_animal.breeding_area_positio
ns[breeding_position_counter].row = animal_position_row + row_offset;   
          my_animal.breeding_area_positions[breeding_position_counter].column
 = animal_position_column + column_offset;             breeding_position_counter
++;           }         }       }   }   my_animal.number_of_breeding_area_positio
ns = breeding_position_counter;   my_board.cell_array_2D[animal_position_row][ani
mal_position_column].animal = my_animal;   my_board.number_of_animals += 1;
\end_layout

\begin_layout Plain Layout

  return my_board; } 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
construct_board.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include "../CellularAutomata.h" #include <stdlib.h> #include <stdio.h>
\end_layout

\begin_layout Plain Layout

Board construct_board(unsigned int number_of_rows, unsigned int number_of_column
s, unsigned int food_growing_rate, unsigned int animal_grazing_rate) { 
  //Constructs the board, with the right size, animals and food.
\end_layout

\begin_layout Plain Layout

	int row_number; 	int column_number; 	Cell my_cell; 	Board my_board; 	Animal
 my_animal; 	Food my_food; 	int animal_position_row; 	int animal_position_column
; 	int food_position_counter = 0;   int step_number = -1;
\end_layout

\begin_layout Plain Layout

	my_board.number_of_rows = number_of_rows; 	my_board.number_of_columns = number_of
_columns;
\end_layout

\begin_layout Plain Layout

	my_board.cell_array_2D = malloc(sizeof(Cell*)*my_board.number_of_rows);
\end_layout

\begin_layout Plain Layout

  //In the present state, my_board.food_positions is useless.
   //But potentially it could be used for defining that food is not present
   //everywhere.
 	my_board.food_positions = malloc(sizeof(Position)*(my_board.number_of_rows*my_bo
ard.number_of_columns));
\end_layout

\begin_layout Plain Layout

	for (row_number=0;row_number<number_of_rows;row_number++) 	{ 		my_board.cell_arr
ay_2D[row_number]=malloc(sizeof(Cell)*my_board.number_of_columns); 		for
 (column_number=0;column_number<number_of_columns;column_number++) 		{ 			my_cel
l = my_board.cell_array_2D[row_number][column_number]; 			my_cell.position.row
 = row_number; 			my_cell.position.column = column_number;
\end_layout

\begin_layout Plain Layout

			///Food set-up 			my_food = my_cell.food; 			my_food.quantity = 100;
\end_layout

\begin_layout Plain Layout

			//Store the places where there's food in a different array 			my_board.food_po
sitions[food_position_counter].row =  my_cell.position.row; 			my_board.food_positio
ns[food_position_counter].column =  my_cell.position.column; 			food_position_count
er++;
\end_layout

\begin_layout Plain Layout

			my_food.growing_rate = food_growing_rate;
\end_layout

\begin_layout Plain Layout

			///No animal except the one defined after the loop 			my_animal = my_cell.anim
al;
\end_layout

\begin_layout Plain Layout

			my_animal.present = 0;
\end_layout

\begin_layout Plain Layout

			my_cell.animal = my_animal; 			my_cell.food = my_food; 			my_board.cell_array_2D
[row_number][column_number] = my_cell;
\end_layout

\begin_layout Plain Layout

		} 	}
\end_layout

\begin_layout Plain Layout

  //In the present state, my_board.amount_of_food is useless.
   //see remark on my_board.food_positions   my_board.amount_of_food  = my_board.nu
mber_of_rows * my_board.number_of_columns;
\end_layout

\begin_layout Plain Layout

	//I'm putting an animal in the centre of my board.
   my_board.number_of_animals = 0; 	animal_position_row = number_of_rows
 / 2; 	animal_position_column = number_of_columns / 2;
\end_layout

\begin_layout Plain Layout

  my_board = construct_animal(my_board, animal_position_row, animal_position_col
umn,     animal_grazing_rate, step_number);
\end_layout

\begin_layout Plain Layout

	return my_board;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
display_board.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include "../CellularAutomata.h" #include <stdlib.h> #include <stdio.h>
\end_layout

\begin_layout Plain Layout

Board construct_board(unsigned int number_of_rows, unsigned int number_of_column
s, unsigned int food_growing_rate, unsigned int animal_grazing_rate) { 
  //Constructs the board, with the right size, animals and food.
\end_layout

\begin_layout Plain Layout

	int row_number; 	int column_number; 	Cell my_cell; 	Board my_board; 	Animal
 my_animal; 	Food my_food; 	int animal_position_row; 	int animal_position_column
; 	int food_position_counter = 0;   int step_number = -1;
\end_layout

\begin_layout Plain Layout

	my_board.number_of_rows = number_of_rows; 	my_board.number_of_columns = number_of
_columns;
\end_layout

\begin_layout Plain Layout

	my_board.cell_array_2D = malloc(sizeof(Cell*)*my_board.number_of_rows);
\end_layout

\begin_layout Plain Layout

  //In the present state, my_board.food_positions is useless.
   //But potentially it could be used for defining that food is not present
   //everywhere.
 	my_board.food_positions = malloc(sizeof(Position)*(my_board.number_of_rows*my_bo
ard.number_of_columns));
\end_layout

\begin_layout Plain Layout

	for (row_number=0;row_number<number_of_rows;row_number++) 	{ 		my_board.cell_arr
ay_2D[row_number]=malloc(sizeof(Cell)*my_board.number_of_columns); 		for
 (column_number=0;column_number<number_of_columns;column_number++) 		{ 			my_cel
l = my_board.cell_array_2D[row_number][column_number]; 			my_cell.position.row
 = row_number; 			my_cell.position.column = column_number;
\end_layout

\begin_layout Plain Layout

			///Food set-up 			my_food = my_cell.food; 			my_food.quantity = 100;
\end_layout

\begin_layout Plain Layout

			//Store the places where there's food in a different array 			my_board.food_po
sitions[food_position_counter].row =  my_cell.position.row; 			my_board.food_positio
ns[food_position_counter].column =  my_cell.position.column; 			food_position_count
er++;
\end_layout

\begin_layout Plain Layout

			my_food.growing_rate = food_growing_rate;
\end_layout

\begin_layout Plain Layout

			///No animal except the one defined after the loop 			my_animal = my_cell.anim
al;
\end_layout

\begin_layout Plain Layout

			my_animal.present = 0;
\end_layout

\begin_layout Plain Layout

			my_cell.animal = my_animal; 			my_cell.food = my_food; 			my_board.cell_array_2D
[row_number][column_number] = my_cell;
\end_layout

\begin_layout Plain Layout

		} 	}
\end_layout

\begin_layout Plain Layout

  //In the present state, my_board.amount_of_food is useless.
   //see remark on my_board.food_positions   my_board.amount_of_food  = my_board.nu
mber_of_rows * my_board.number_of_columns;
\end_layout

\begin_layout Plain Layout

	//I'm putting an animal in the centre of my board.
   my_board.number_of_animals = 0; 	animal_position_row = number_of_rows
 / 2; 	animal_position_column = number_of_columns / 2;
\end_layout

\begin_layout Plain Layout

  my_board = construct_animal(my_board, animal_position_row, animal_position_col
umn,     animal_grazing_rate, step_number);
\end_layout

\begin_layout Plain Layout

	return my_board;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
graze.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board graze(Board my_board, Animal my_animal) {   //An animal grazes (eats)
 in all adjacent cells (at most 1 cell away,   //including diagonals) on
 the board.
\end_layout

\begin_layout Plain Layout

	Cell my_grazed_cell; 	int number_position_grazing_area; 	int my_grazed_cell_row
; 	int my_grazed_cell_column;
\end_layout

\begin_layout Plain Layout

	for(number_position_grazing_area=0;number_position_grazing_area<9;number_positi
on_grazing_area++) 	{ 		my_grazed_cell_row = my_animal.grazing_area_positions[num
ber_position_grazing_area].row; 		my_grazed_cell_column = my_animal.grazing_area_p
ositions[number_position_grazing_area].column;
\end_layout

\begin_layout Plain Layout

		my_grazed_cell = my_board.cell_array_2D[my_grazed_cell_row][my_grazed_cell_colu
mn];
\end_layout

\begin_layout Plain Layout

    //If the grazed cell has enough food for the animal's grazing rate 		if(my_g
razed_cell.food.quantity >= my_animal.grazing_rate) 		{ 		//Reducing the amount
 of food in the cell 		my_grazed_cell.food.quantity -= my_animal.grazing_rate;
 			//Storing that food in the animal       //The amount of food stored
 by an animal can't exceed 100.
 			if(my_animal.food_stored + my_animal.grazing_rate <= 100) 			my_animal.food_sto
red += my_animal.grazing_rate; 			else 			my_animal.food_stored = 100; 		}
 		//If the grazed cell doesn't have enough food for the animal's grazing_rate
 		else 		{       //Storing what's left food in the animal       //The amount
 of food stored by an animal can't exceed 100.
 			if(my_animal.food_stored + my_grazed_cell.food.quantity <= 100) 			my_animal.foo
d_stored += my_grazed_cell.food.quantity; 			else 			my_animal.food_stored
 = 100;
\end_layout

\begin_layout Plain Layout

			my_grazed_cell.food.quantity = 0; 		}
\end_layout

\begin_layout Plain Layout

		// I'm passing variables by value so I need to do lots of copying.
 		// Passing by reference would be more memory efficient.
 		my_board.cell_array_2D[my_grazed_cell_row][my_grazed_cell_column] = my_grazed_
cell; 	} 	my_board.cell_array_2D[my_animal.position.row][my_animal.position.column].an
imal = my_animal;
\end_layout

\begin_layout Plain Layout

	return(my_board); } 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
grow_food.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board grow_food(Board my_board) {   //Food grows everywhere there was ever
 food, in accordance to their growing_rate.
   //By default, food is everywhere, so food grows everywhere.
\end_layout

\begin_layout Plain Layout

int food_number; int my_food_row; int my_food_column;
\end_layout

\begin_layout Plain Layout

for (food_number=0; food_number < my_board.amount_of_food; food_number++)
 	{
\end_layout

\begin_layout Plain Layout

	my_food_row = my_board.food_positions[food_number].row; 	my_food_column =
 my_board.food_positions[food_number].column;
\end_layout

\begin_layout Plain Layout

  //The amount of food stored in a cell can't exceed 100.
 	if(my_board.cell_array_2D[my_food_row][my_food_column].food.quantity <= 
    100 - my_board.cell_array_2D[my_food_row][my_food_column].food.growing_rate)
\end_layout

\begin_layout Plain Layout

  //Every turn, food regrows by its growing_rate.
 	my_board.cell_array_2D[my_food_row][my_food_column].food.quantity +=   my_board.ce
ll_array_2D[my_food_row][my_food_column].food.growing_rate;
\end_layout

\begin_layout Plain Layout

	else 	my_board.cell_array_2D[my_food_row][my_food_column].food.quantity =
 100;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

return(my_board);
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
live.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board live(Board my_board, Animal my_animal) {   //An animal lives, which
 consumes energy by using up the food they have stored.
\end_layout

\begin_layout Plain Layout

	if(my_animal.food_stored > 10)   { 	my_animal.food_stored -= 10;   }   //If
 the animal food consumption exceeds the amount of food he stored, it dies.
 	else 	{ 	my_animal.present = 0; 	my_animal.alive = 0;   my_board.number_of_animal
s -= 1; 	}
\end_layout

\begin_layout Plain Layout

	my_board.cell_array_2D[my_animal.position.row][my_animal.position.column].animal
 = my_animal;
\end_layout

\begin_layout Plain Layout

	return(my_board); } 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
perform_step.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h> #include <stdlib.h> #include "../CellularAutomata.h"
\end_layout

\begin_layout Plain Layout

Board perform_step(Board my_board, int animal_grazing_rate, int step_number,
 int verbose_flag_chosen) {   //A step of the game is performed.
\end_layout

\begin_layout Plain Layout

	int number_of_animals; 	int amount_of_food;   int row_number;   int column_numb
er;   int my_animal_eligible;   Cell my_cell; 	Animal my_animal; 	Position
 my_animal_position;
\end_layout

\begin_layout Plain Layout

  my_board = grow_food(my_board);
\end_layout

\begin_layout Plain Layout

  if (verbose_flag_chosen)   {   printf("
\backslash
nFood growing.
\backslash
n");   display_board(my_board);   }
\end_layout

\begin_layout Plain Layout

  for (row_number=0;row_number<my_board.number_of_rows;row_number++)   {
     for (column_number=0;column_number<my_board.number_of_columns;column_number+
+)     {     my_cell = my_board.cell_array_2D[row_number][column_number];
     my_animal = my_cell.animal;
\end_layout

\begin_layout Plain Layout

    //An animal can perform actions if it is present, alive, and born in
 a previous     //step.
     my_animal_eligible = (my_animal.present && my_animal.alive       && (my_anima
l.step_of_birth < step_number));
\end_layout

\begin_layout Plain Layout

    if (my_animal_eligible)     {   		my_board = graze(my_board, my_animal);
       //Ugly, passing by reference my_animal would be better.
       //But it can only be done by a pointer (not just by passing the reference
, in C).
       my_animal = my_board.cell_array_2D[my_animal.position.row][my_animal.position.
column].animal;
\end_layout

\begin_layout Plain Layout

      if (verbose_flag_chosen)       {       printf("Animal at row %d and
 column %d grazing.
\backslash
n", my_animal.position.row,     my_animal.position.column);       display_board(my_b
oard);       }
\end_layout

\begin_layout Plain Layout

  		my_board = live(my_board, my_animal);       my_animal = my_board.cell_array_2
D[my_animal.position.row][my_animal.position.column].animal;
\end_layout

\begin_layout Plain Layout

      if (verbose_flag_chosen)       {       printf("Animal at row %d and
 column %d living (consuming food).
\backslash
n", my_animal.position.row,     my_animal.position.column);       display_board(my_b
oard);       }
\end_layout

\begin_layout Plain Layout

      my_board = breed(my_board, my_animal, animal_grazing_rate, step_number);
\end_layout

\begin_layout Plain Layout

      if (verbose_flag_chosen)       {       printf("Animal at row %d and
 column %d breeding.
\backslash
n", my_animal.position.row,     my_animal.position.column);       display_board(my_b
oard);       }
\end_layout

\begin_layout Plain Layout

    }     } 	}
\end_layout

\begin_layout Plain Layout

	return(my_board);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio_cellular_automaton"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
